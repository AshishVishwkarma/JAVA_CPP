dbx is an interactive, source-level, command-line debugging tool. You can use it to run a program in a controlled manner and to inspect the state of a stopped program.

NOTE: You must prepare your program for source-level debugging with dbx by compiling it with the -g option, which is accepted by the C compiler, C++ compiler, Fortran 95 compiler, and Java compiler.

By default, dbx looks in the directory in which the program was compiled for the source files associated with the program being debugged. If the source or object files are not there or the machine you are using does not use the same path name, you must inform dbx of their location.

[43]
pathmap:
The pathmap command maps one path name to another for finding source files and such. The mapping is applied to source paths, object file paths and the current working directory (if you specify -c).
The pathmap command is useful for dealing with automounted and explicit NFS mounted filesystems with different paths on differing hosts. The pathmap command is also useful if source or build trees are moved.
pathmap [ -c ] [ -index ] from to 
	Establish a new mapping from from to to. from and to are filepath prefixes. from refers to the filepath compiled into the executable or object file and to refers to the filepath at debug time.
pathmap 
	List all existing path mappings (by index).
pathmap -s 
	The same, but the output can be read by dbx.	
pathmap -d from1 from2 ... 
	Delete the given mappings by path. from1 is filepath of the first mapping to be deleted. from2 is filepath of the last mapping to be deleted.

Specifying Source Directories:
Based on the information contained in an object file's symbol table, dbx determines from which source files the program was compiled and prints portions of these files as appropriate.
Object files compiled with -g record the absolute path names to the source files. Each time dbx needs a source file, it first searches the absolute path for the source file. If the source file is not present (or if the object file was not compiled with -g), dbx checks its own list of directories for source files.
By default, the dbx directory list contains only the current directory (from which you invoked dbx) and the object file's directory (if it is different from the current directory). Each time dbx searches this list, it searches all directories in the list in the order in which they appear until it finds the file with the specified name.

NOTE: dbx uses system libraries in /usr/lib to help understand the implementation details of the run time linker and threads library on the system.

To Eliminate the Library Problems and Debug a“mismatched”Core File:
- Set the dbx environment variable core_lo_pathmap to on.
- Use the pathmap command to tell dbx where the correct libraries for the core file are located.
- Use the debug command to load the program and the core file.
For example, assuming that the root partition of the core-host has been exported over NFS and can be accessed using /net/core-host/ on the dbx-host machine, you would use the following commands to load the program prog and the core file prog.core for debugging:
(dbx) dbxenv core_lo_pathmap on
(dbx) pathmap /usr /net/core-host/usr
(dbx) pathmap /appstuff /net/core-host/appstuff
(dbx) debug prog prog.core
If you are not exporting the root partition of the core-host, you must copy the libraries by hand.
You need not re-create the symbolic links. (For example, you need not make a link from libc.so to libc.so.1; just make sure libc.so.1 is available.)


bash:lonss00049:/home/vishwaf> dbx -V
Sun Dbx Debugger 7.6 SunOS_sparc 2007/05/03
For information about new features see `help changes'
To remove this message, put `dbxenv suppress_startup_message 7.6' in your .dbxrc

-----------------------------------
set a stop breakpoint to stop in a function or procedure:
	stop in main
	
	
sudo su - sabrebat	
	
dbx /apps/risk/source/PREPROCESSORS/gte_repo_trade_p.exe

To change the source file path:
	(dbx) pathmap /home/vishwaf/CVS_REPO/SABRECVS/OPER/source/PREPROCESSORS /apps/risk/source/PREPROCESSORS
	(dbx) pathmap /home/kotharf/work/SABRECVS/OPER/common /apps/common
	
Set break points:	
	(dbx) stop in process_repo_trade
	(dbx) stop at 656
	
	
Stopping Execution When Variables Change:
	(dbx) stop change variable
	Keep these points in mind when using the stop change command:
	- dbx stops the program at the line after the line that caused a change in the value of the specified variable.
	- If variable is local to a function, the variable is considered to have changed when the function is first entered and storage for variable is allocated. The same is true with respect to parameters.
	- The command does not work with multithreaded applications.
	
	dbx implements stop change by causing automatic single stepping together with a check on the value at each step. Stepping skips over library calls if the library was not compiled with the -g option.
	NOTE: dbx cannot set a breakpoint for a change in a block local variable—a variable nested in {}. If you try to set a breakpoint or trace in a block local “nested” variable, dbx issues an error informing you that it cannot perform this operation.

	(dbx) stop change tr.gbp_mtm -in write_sec_and_loan_trades

	NOTE: Makes execution of the program slow.

To get a list of all current breakpoints use the status command:
	(dbx) status

Deleting Specific Breakpoints Using Handler ID Numbers:	
	(dbx) delete 5 6
	
To delete all breakpoints set in the program currently loaded:
	(dbx) delete all
	
Pass parameters to the program:	
	(dbx)run -trepo.estr.dat
	
Look at call-stack:
	where
	
Examining Variables:
	print var_name
	
next

next [n]
	This command will execute through the next n source lines and then stop. Procedure and function calls are counted as one statement, i.e.. 'next' steps over them.

step
	attempts to step into a specified function in the current source line, or if no function is specified, into the last function called as determined by the assembly code for the current source line.
	
step [n]
	This command will execute through the next n source lines and then stop. Procedure and function calls that are executed are also counted, i.e.. 'step' steps into them.	

step up 
	continues execution until the current function returns control to the function that called it.
	
cont
	Will resume execution from the current breakpoint until the next breakpoint is encountered or the program finishes (whichever is occurs first).


cont no_of_lines
	Will resume execution on current_line+no_of_lines, relative to the current file and must be within the current procedure/function.
	Bypass all lines of code between current_line and current_line+no_of_lines.

run
	restarted program with previous parameter!
	
loadobject -list
	List of all shared libraries that are loaded with dlopen().
	Run your program under dbx to completion. dbx records and remembers all shared libraries that are loaded with dlopen(2), even if they are closed with dlclose().

exists	
file
func
list
listi
modules

examine or x :
	examine [address] [/ [count] [format]]
	NOTE: Symbolic addresses used to display memory are specified by preceding a name with an ampersand (&). Function names can be used without the ampersand; &main is equal to main. Registers are denoted by preceding a name with a dollar sign ($).
	format:
		i    Display as an assembly instruction.
		d    Display as 16 bits (2 bytes) in decimal.
		D    Display as 32 bits (4 bytes) in decimal.
		o    Display as 16 bits (2 bytes) in octal.
		O    Display as 32 bits (4 bytes) in octal.
		x    Display as 16 bits (2 bytes) in hexadecimal.
		X    Display as 32 bits (4 bytes) in hexadecimal. (default format)
		b    Display as a byte in octal.
		c    Display as a character.
		w    Display as a wide character.
		s    Display as a string of characters terminated by a null byte.
		W    Display as a wide character.
		f    Display as a single-precision floating point number.
		F, g    Display as a double-precision floating point number.
		E    Display as an extended-precision floating point number.
		ld, lD    Display 32 bits (4 bytes) in decimal (same as D).
		lo, lO    Display 32 bits (4 bytes) in octal (same as O).
		lx, LX    Display 32 bits (4 bytes) in hexadecimal (same as X).
		Ld, LD    Display 64 bits (8 bytes) in decimal.
		Lo, LO    Display 64 bits (8 bytes) in octal.
		Lx, LX    Display 64 bits (8 bytes) in hexadecimal.

	Display the address, instead of the contents of the address in the given format
		examine address = [format]	

Quitting dbx:
	quit
----------------------------------------------------------------------	
On GDB:
For the current stack frame:

	info frame lists general info about the frame (where things start in memory, etc.)
	info args lists arguments to the function
	info locals lists local variables stored in the frame

----------------------------------------------------------------------
Tracing Execution:
	Tracing collects information about what is happening in your program and displays it. If a program arrives at a breakpoint created with a trace command, the program halts and an event-specific trace information line is emitted, then the program continues.
(dbx) trace in write_sec_and_loan_trades
(dbx) trace infunction write_sec_and_loan_trades
Directing Trace Output to a File:
	(dbx) trace -file /home/vishwaf/trace_log	

----------------------------------------------------------------------
(dbx) loadobject -list
u   /apps/risk/source/PREPROCESSORS/calypso_trade_p.exe (primary)
u   /lib/libpthread.so.1
u   /lib/libthread.so.1
u   /opt/sybaseSW/sybase12.5/OCS-12_5/lib/libintl_r.so
u   /opt/sybaseSW/sybase12.5/OCS-12_5/lib/libcomn_r.so
u   /lib/libdl.so.1
u   /lib/libnsl.so.1
u   /opt/sybaseSW/sybase12.5/OCS-12_5/lib/libct_r.so
u   /opt/sybaseSW/sybase12.5/OCS-12_5/lib/libtcl_r.so
u   /opt/sybaseSW/sybase12.5/OCS-12_5/lib/libcs_r.so
u   /lib/libm.so.2
u   /lib/libc.so.1
u   /lib/libsocket.so.1
u   /platform/sun4u-us3/lib/libc_psr.so.1
u p /lib/nss_files.so.1

	
